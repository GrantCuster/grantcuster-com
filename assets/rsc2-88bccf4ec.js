import{r as t,R as q,u as B,p as W,S as T,T as H,g as K,c as N}from"./client-gX9D-yfm.js";const A="R";function b(e){if(!e.startsWith("/"))throw new Error("Path must start with `/`: "+e);if(e==="/")return A+"/_root";if(e.endsWith("/"))throw new Error("Path must not end with `/`: "+e);return A+e}const j="ROUTE",X="IS_STATIC",z="HAS404",v="X-Waku-Router-Skip",J=e=>{for(const n of["/","/index.html"])if(e.endsWith(n))return e.slice(0,-n.length)||"/";return e},S=e=>{const{pathname:n,searchParams:r,hash:c}=e;return{path:J(n),query:r.toString(),hash:c}},Y=()=>globalThis.__WAKU_ROUTER_404__?{path:"/404",query:"",hash:""}:S(new URL(window.location.href));let C;const I=e=>{if(C&&C[0]===e)return C[1];const n=new URLSearchParams({query:e});return C=[e,n],n},k=t.createContext(null);function ee(){const e=t.useContext(k);if(!e)throw new Error("Missing Router");const{route:n,changeRoute:r,prefetchRoute:c}=e,i=t.useCallback((E,a)=>{const o=new URL(E,window.location.href),s=o.pathname!==window.location.pathname;window.history.pushState({...window.history.state,waku_new_path:s},"",o),r(S(o),{shouldScroll:(a==null?void 0:a.scroll)??s})},[r]),u=t.useCallback((E,a)=>{const o=new URL(E,window.location.href),s=o.pathname!==window.location.pathname;window.history.replaceState(window.history.state,"",o),r(S(o),{shouldScroll:(a==null?void 0:a.scroll)??s})},[r]),m=t.useCallback(()=>{const E=new URL(window.location.href);r(S(E),{shouldScroll:!0})},[r]),p=t.useCallback(()=>{window.history.back()},[]),l=t.useCallback(()=>{window.history.forward()},[]),d=t.useCallback(E=>{const a=new URL(E,window.location.href);c(S(a))},[c]);return{...n,push:i,replace:u,reload:m,back:p,forward:l,prefetch:d}}function te({to:e,children:n,scroll:r,unstable_pending:c,unstable_notPending:i,unstable_prefetchOnEnter:u,unstable_prefetchOnView:m,unstable_startTransition:p,...l}){const d=t.useContext(k),E=d?d.changeRoute:()=>{throw new Error("Missing Router")},a=d?d.prefetchRoute:()=>{throw new Error("Missing Router")},[o,s]=t.useTransition(),f=p||(c||i)&&s||(w=>w()),h=t.useRef(void 0);t.useEffect(()=>{if(m&&h.current){const w=new IntersectionObserver(R=>{R.forEach(_=>{if(_.isIntersecting){const g=new URL(e,window.location.href);if(d&&g.href!==window.location.href){const U=S(g);d.prefetchRoute(U)}}})},{threshold:.1});return w.observe(h.current),()=>{w.disconnect()}}},[m,d,e]);const y=w=>{var _;w.preventDefault();const R=new URL(e,window.location.href);if(R.href!==window.location.href){const g=S(R);a(g),f(()=>{const U=R.pathname!==window.location.pathname;window.history.pushState({...window.history.state,waku_new_path:U},"",R),E(g,{shouldScroll:r??U})})}(_=l.onClick)==null||_.call(l,w)},L=u?w=>{var _;const R=new URL(e,window.location.href);if(R.href!==window.location.href){const g=S(R);a(g)}(_=l.onMouseEnter)==null||_.call(l,w)}:l.onMouseEnter,P=t.createElement("a",{...l,href:e,onClick:y,onMouseEnter:L,ref:h},n);return o&&c!==void 0?t.createElement(t.Fragment,null,P,c):!o&&i!==void 0?t.createElement(t.Fragment,null,P,i):P}const F=e=>()=>{throw new Error(`${e} is not in the server`)};function x(e){return t.createElement("html",null,t.createElement("body",null,t.createElement("h1",null,e)))}class ne extends t.Component{constructor(n){super(n),this.state={}}static getDerivedStateFromError(n){return{error:n}}render(){return"error"in this.state?this.state.error instanceof Error?x(this.state.error.message):x(String(this.state.error)):this.props.children}}const $=({has404:e,reset:n})=>{const r=N(),c=t.useContext(k);if(!c)throw new Error("Missing Router");const{changeRoute:i}=c;return t.useEffect(()=>{if(e){const u=new URL("/404",window.location.href);i(S(u),{shouldScroll:!0}),r==null||r(),n()}},[e,r,n,i]),e?null:t.createElement("h1",null,"Not Found")},G=({to:e,reset:n})=>{const r=N(),c=t.useContext(k);if(!c)throw new Error("Missing Router");const{changeRoute:i}=c;return t.useEffect(()=>{const u=new URL(e,window.location.href);if(u.hostname!==window.location.hostname){window.location.replace(e);return}const m=u.pathname!==window.location.pathname;window.history.pushState({...window.history.state,waku_new_path:m},"",u),i(S(u),{shouldScroll:m}),r==null||r(),n()},[e,r,n,i]),null};class M extends t.Component{constructor(n){super(n),this.state={error:null},this.reset=this.reset.bind(this)}static getDerivedStateFromError(n){return{error:n}}reset(){this.setState({error:null})}render(){const{error:n}=this.state;if(n!==null){const r=K(n);if((r==null?void 0:r.status)===404)return t.createElement($,{has404:this.props.has404,reset:this.reset});if(r!=null&&r.location)return t.createElement(G,{to:r.location,reset:this.reset});throw n}return this.props.children}}const O=e=>"route:"+decodeURIComponent(e),Q=()=>{const{hash:e}=window.location,{state:n}=window.history,r=e&&document.getElementById(e.slice(1));window.scrollTo({left:0,top:r?r.getBoundingClientRect().top+window.scrollY:0,behavior:n!=null&&n.waku_new_path?"instant":"auto"})},Z=({routerData:e,initialRoute:n})=>{const[r,c,,i]=e,u=B(),[m,p]=t.useState(()=>({...n,hash:""}));t.useEffect(()=>{p(o=>o.path===n.path&&o.query===n.query&&o.hash===n.hash?o:n)},[n]);const l=t.useCallback((o,s)=>{const{skipRefetch:f}=s||{};if(!c.has(o.path)&&!f){const h=b(o.path),y=I(o.query);u(h,y)}s.shouldScroll&&Q(),p(o)},[u,c]),d=t.useCallback(o=>{var h;if(c.has(o.path))return;const s=b(o.path),f=I(o.query);W(s,f),(h=globalThis.__WAKU_ROUTER_PREFETCH__)==null||h.call(globalThis,o.path)},[c]);t.useEffect(()=>{const o=()=>{const s=S(new URL(window.location.href));l(s,{shouldScroll:!0})};return window.addEventListener("popstate",o),()=>{window.removeEventListener("popstate",o)}},[l]),t.useEffect(()=>{const o=(s,f)=>{const h=new URL(window.location.href);h.pathname=s,h.search=f,h.hash="",s!=="/404"&&window.history.pushState({...window.history.state,waku_new_path:h.pathname!==window.location.pathname},"",h),l(S(h),{skipRefetch:!0,shouldScroll:!1})};return r.add(o),()=>{r.delete(o)}},[l,r]);const E=t.createElement(T,{id:O(m.path)}),a=t.createElement(T,{id:"root",unstable_handleError:t.createElement(M,{has404:i},t.createElement(H))},t.createElement(M,{has404:i},E));return t.createElement(k.Provider,{value:{route:m,changeRoute:l,prefetchRoute:d}},a)},V=[];function re({routerData:e=V,initialRoute:n=Y(),unstable_enhanceFetch:r,unstable_enhanceCreateData:c}){const i=b(n.path),u=e[0]||(e[0]=new Set),m=e[1]||(e[1]=new Set),p=e[2]||(e[2]=new Set),l=a=>(o,s={})=>{const f=JSON.stringify(Array.from(p)),h=s.headers||(s.headers={});return Array.isArray(h)?h.push([v,f]):h[v]=f,a(o,s)},d=a=>async o=>{const s=a(o);return Promise.resolve(s).then(f=>{if(f&&typeof f=="object"){const{[j]:h,[X]:y,[z]:L,...P}=f;if(h){const[w,R]=h;(window.location.pathname!==w||!y&&window.location.search.replace(/^\?/,"")!==R)&&u.forEach(_=>_(w,R)),y&&m.add(w)}L&&(e[3]=!0),Object.keys(P).forEach(w=>{p.add(w)})}}).catch(()=>{}),s},E=I(n.query);return t.createElement(q,{initialRscPath:i,initialRscParams:E,unstable_enhanceFetch:r?a=>r(l(a)):l,unstable_enhanceCreateData:c?a=>c(d(a)):d},t.createElement(Z,{routerData:e,initialRoute:n}))}function oe({route:e}){const n=t.createElement(T,{id:O(e.path)}),r=t.createElement(T,{id:"root",unstable_handleError:null},n);return t.createElement(t.Fragment,null,t.createElement(k.Provider,{value:{route:e,changeRoute:F("changeRoute"),prefetchRoute:F("prefetchRoute")}},r))}export{ne as ErrorBoundary,oe as INTERNAL_ServerRouter,te as Link,re as Router,ee as useRouter_UNSTABLE};
